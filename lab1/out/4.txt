import java.rmi.*;
import java.rmi.server.*;
import java.util.*;
import java.io.*;
import java.lang.reflect.*;
class ProcessDelegationServer extends UnicastRemoteObject implements MasterServerInterface
    private static final String serverName = "processDelegationServer";
    private volatile List<ProcessManagerClientInterface> clients;
    private volatile List<String> processIDs;
	private HashMap<ProcessManagerClientInterface,List<String>> files;
    public int nextPid;
    
	private boolean running;
	private static final int BALANCE_LEVEL = 2;
    public ProcessDelegationServer() throws RemoteException
    {
        //Any constructor methods   
        clients = new ArrayList<ProcessManagerClientInterface>();
        processIDs = new ArrayList<String>(); 
		nextPid = 0;
		running = false;
		files = new HashMap<ProcessManagerClientInterface,List<String>>(); 
    }
    
	// Assigns unassigned processes in processIDs to first client
	public void assignProcesses() {
		// Get current processes 
		List<String> currentPs = new ArrayList<String>(); 
			for(ProcessManagerClientInterface client : clients) {
				try {
				} catch(ConnectException|UnmarshalException e)
					System.out.println("Client disconnected");
				} 
				catch(Exception e)
		} catch(ConcurrentModificationException e)
				} 
		// Find unassigned ones and send them to first client 
		List<String> add = new ArrayList<String>(processIDs);
		if(processIDs.size() > 0 && clients.size() > 0) {
				System.out.println("First Client Set");
			} 
			catch(ConnectException|UnmarshalException e)
				System.out.println("Client disconnected");
			} 
			catch(Exception e)
	// balances load between clients 
	public void loadBalance() throws RemoteException {
		// victim is the client that takes on additional load
		int avg = 0; 
		int victim = 0;
agerClientInterface client : clients) {
			avg = avg + client.getProcesses().size();
		if (clients.size() != 0) 
			avg = avg / clients.size();
			avg = 0;
		//balance the load of clients by getting a process from an overloaded client and sending it to a random other one
		for(ProcessManagerClientInterface c : clients) {
			ps = files.get(c);
			load = ps.size();
			while(load - BALANCE_LEVEL > avg) {
				//designate victim
				do {
					victim = r.nextInt(clients.size());
				} while(victim == current) ;
				//move process
				victimC = clients.get(victim);
				victimPs = files.get(victimC);
				f = ps.remove(0); 
			current++; 
		//set all changes
		for(ProcessManagerClientInterface c : clients) {
			// TODO: needs some sort of try/catch
			ps = files.get(c);
    public static void main (String []args)
    {
        try
        {
            //Server Stuff
            ProcessDelegationServer server = new ProcessDelegationServer();
            Naming.rebind (serverName, server);
            System.out.println("Process Delegation Server Ready");
        
            for(int i = 0; i < 10; i++) {
                Class<? extends MigratableProcess> processClass = GrepProcess.class;
                String outputFileName = "out/" + i + ".txt";
                String[] strings = {"1", "in.txt", outputFileName};
                Object[] arguments = {strings};
                server.addProcess(processClass, arguments);
	    	}
            while (true)
            {
                server.loadBalance();	
                Thread.sleep(1000);
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
    public void register(ProcessManagerClientInterface newClient) throws RemoteException
    {
        System.out.println("Client Connected");
		System.out.println("Current processes " + processIDs.size()); 
        clients.add(newClient);
    }
    
    public void addProcess(Class<? extends MigratableProcess> processClass, Object[] args)
    {
        MigratableProcess newProcess = null;
        Class[] classes = new Class[args.length];
        for(int i = 0; i < args.length; i++)
        {
            classes[i] = args[i].getClass();
        }
        Constructor<?> constructor = null;
        try { 
            constructor = processClass.getConstructor(classes);
        } catch (NoSuchMethodException e)
        {
            Constructor<?>[] constructors = processClass.getConstructors();
            System.out.println("Possible constructors are: \n" + Arrays.toString( constructors ));
            System.out.println("Incorrect arguments for class");
            e.printStackTrace();
        }
        
        try {
            newProcess = (MigratableProcess) constructor.newInstance(args);
        } catch (Exception e)
        {
            System.out.println("Failed to create class instance");
            e.printStackTrace();
        }
        try {
            String fileName = "processes/" + nextPid;
	    	nextPid++;
            File newProcessFile = new File(fileName);
            newProcessFile.createNewFile();
            ProcessIO.writeProcess(newProcess, fileName);
	    	System.out.println("Process Written " +  fileName);
            processIDs.add(fileName); 
        } catch (Exception e)
        {
            System.out.println("Failed to make file for process");
            e.printStackTrace();
        }
     newProcess = (MigratableProcess) constructor.newInstance(args);
        } catch (Exception e)
        {
            System.out.println("Failed to create class instance");
            e.printStackTrace();
        }
        try {
            String fileName = "processes/" + nextPid;
	    	nextPid++;
            File newProcessFile = new File(fileName);
            newProcessFile.createNewFile();
            ProcessIO.writeProcess(newProcess, fileName);
	    	System.out.println("Process Written " +  fileName);
            processIDs.add(fileName); 
        } catch (Exception e)
        {
            System.out.println("Failed to make file for process");
            e.printStackTrace();
        }
    }
    private void updateProcessList()
    {
        for (int i = 0; i < processIDs.size(); i++)
        {
            String fileName = processIDs.get(i);
            File processFile = new File(fileName);
            //If the file is deleted, the process is completed
            if (!processFile.exists())
            {
                System.out.println("Removing " + fileName);
                processIDs.remove(i);
            }
        }
    }
    private String nextPid() {
        for(int i = 0; i <= Integer.MAX_VALUE; i++) {
            if(processIDs.contains(Integer.toString(i)) == false)
                return (Integer.toString(i));
        }
        return Integer.toString(-1);
    }
())
            {
                System.out.println("Removing " + fileName);
                processIDs.remove(i);
            }
        }
    }
	
    private String nextPid() {
        for(int i = 0; i <= Integer.MAX_VALUE; i++) {
            if(processIDs.contains(Integer.toString(i)) == false)
                return (Integer.toString(i));
        }
        return Integer.toString(-1);
    }

}
