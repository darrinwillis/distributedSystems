~6499
"######~1
";~2
"Not~1
"\n######~2
"\n\tTasks~1
"\t\tTask~1
"part"~3
######\n");~2
######\n";~3
(!foundNode.beenCleaned)~1
(!iter.hasNext())~1
(!jobMapNodeList.get(j.getJid()).contains(nodes.get(name).server))~1
((tempNodeSize~1
(DistributedFile~2
(FileNotFoundException~1
(InterruptedException~1
(eachNode.isConnected~1
(foundNode~1
(host~1
(iter.hasNext())~5
(optimalNode~1
(t~1
//////////////////~1
//Adds~1
//Distribute~1
//Instance~1
//Prints~1
//Remove~1
//close~1
//compile~1
//file~2
//final~1
//jobReducesDone.remove(j.getJid());~1
//location~1
0~3
1;~2
<~5
>=~2
?~6
BE~1
Bind~1
BufferedReader(new~1
Clean~1
Config.checkConfigFile())~1
Config.getLocalDirectory();~2
Config.getNodeAddresses();~1
Connected");~1
Copy~1
End~2
File~6
File(Config.getLocalDirectory());~1
File(fileName),f);//dowload~1
FileIO.download(node.server,new~1
FileIO.upload(server,~1
FileInputStream(f)));~1
FileWriter(j.getOutput(),true)));~1
Files");~1
Get~1
HashSet<Node>();~1
Heartbeater~2
Heartbeater();~1
IOException~3
Integer~3
Iterate~1
Iterator<String>~1
Iterator<Task>~1
LinkedList<Job>();~1
LinkedList<Node>(nodes.values());~1
LinkedList<Object[]>~1
LocateRegistry.getRegistry(registryPort);~1
Map<Node,~1
MapTask~2
MapTask(tid++,jid,null,j,"");~1
MapTask)~1
Mappers~1
MasterServer~2
MasterServer()~1
MasterServer();~1
No~1
Node~14
Node();~1
Node>();~1
OutputStream~1
Queue<Job>~1
Reducers~1
Reduces!");~1
SHOULD~1
STATUS~1
Scheduler()~1
Serializable~1
Set<Node>~1
String~15
System.out.println("Adding~1
System.out.println("Client~1
System.out.println("Compiling~1
System.out.println("DONE");~1
System.out.println("Downloaded~1
System.out.println("Finished~2
System.out.println("Heartbeater~1
System.out.println("Hit~1
System.out.println("No~1
System.out.println("Scheduler~2
System.out.println("Scheduling~2
System.out.println("Server~1
System.out.println("Starting~2
System.out.println("Unexporting~2
System.setProperty("sun.rmi.transport.tcp.responseTimeout",~3
THIS~1
Tasks");~3
This~6
addNode(iter.next());~1
added~2
addresses~1
allows~2
already~3
are~3
are:\n"~2
at~1
beenCleaned;~1
block[i];~1
by~1
can~1
cannot~1
catch(Exception~3
char[]~1
check~3
checked~1
chosen~1
class~4
configFileName~1
configFileName);~1
create~1
currentTid;~1
d;~1
destination.files.add(eachPartition);~1
dfile~5
download~1
e.getMessage());~1
each.files.listIterator();~1
each.name);~1
each.server.getStatus();~1
each.server;~1
each.status~1
eachBlock)~1
eachFile~1
eachNode~2
eachPartition~2
eachPartition.getFileName()~1
eachServer~1
en.nextElement();~1
extends~3
f~1
f:localDir.listFiles())~1
file...");~1
fileList)~2
fileList;~1
files~3
final~3
finally~1
find~1
findDistributedFile(String~1
findDistributedFile(j.getInput());~1
for~10
for(Object[]~1
format~1
found~1
found");~2
foundNode~1
foundNode.cores~1
foundNode.server~1
foundNode.server);~1
fp.getIndex()~1
getOutputStream(File~1
have~1
heartbeater.start();~1
heartbeater;~1
higher~1
host");~1
i~8
if~22
import~7
in.close();~1
instanceof~1
j)~3
j.getJid()~2
j.getJid());~1
j.getTotalMaps())~1
java.net.*;~1
java.util.concurrent.*;~1
jobMapNodeList.get(j.getJid()).add(nodes.get(name).server);~1
jobMapsDone.get(j.getJid())~1
jobMapsDone.put(j.getJid(),maps);~1
jobMapsDone.put(jid,0);~1
jobMapsDone;~1
jobReduceNodeList.get(j.getJid()).put(t.getOutputFile(),nodes.get(name));~1
jobReduceNodeList.put(jid,new~1
jobReducesDone;~1
jobs.add(j);~1
jobs;~1
line;~1
list~1
locally~1
m)~1
main(String[]~1
masterServerRegistryKey;~1
message");~2
monitorNodes()~1
n.files.size());~1
n.name);~3
n.status.mapSlots~1
name~1
name);~1
new~36
newAddress~2
newAddress;~1
newFile);~1
newNode);~1
newNode.name~1
newNode.server~1
newStat;~1
newsize~1
nodeEnum~1
nodeQueue.add(nodeQueue.removeFirst());~1
nodeQueue.remove(n);~2
nodes~13
nodes");~1
ns~1
null){~1
number~1
numberof~1
object~1
of~8
oldsize~1
oldsize)~1
optSize~2
or~3
other~1
out.print(b);//appends~1
outputs~1
partitionFile(File~1
partitionFile,~1
probably~1
r~1
r.setNodeId(i);~1
reduces~1
registry,~1
remote~3
replicas~1
rmiRegistry~2
s.concat("\nReport~1
s.concat("\n\n######~3
s.concat("\n\t"~2
s.concat("\n\t\tStatus:~1
s.concat(iter.hasNext()~1
s;~3
schedule~1
scheduleFinalReduce(j);~1
scheduleReduce((ReduceTask)t);~1
scheduleReducers(j);~1
sec~1
send~1
should~2
size:~1
start~1
status~1
stop()~1
stopping~1
taken~1
taskIter~1
tasks.removeFirst();~2
tempSize~1
the~22
this.currentNodeId~1
this.fileList~1
this.fileList.add(dfile);~1
this.isRunning~2
this.jobMapsDone~1
this.jobReduceNodeList~1
this.nodes.elements();~4
through~2
throws~16
tid~2
timeout~1
true;~3
try~4
try{~11
unexportObject(this,~1
user~1
while~11
whole~1
with~2
{~88
!=~4
"~47
"5000");~3
"\t\t"~1
&&~3
(!~1
(!placedNodes.contains(eachNode)))~1
((host~1
(File~1
(Node~1
(Task)objs[1];~1
(each.server~1
(eachServer~1
(enumerate.hasMoreElements())~1
(foundNode.isConnected)~1
(n.isConnected~1
(server~1
(thisSize~1
+~70
//~28
//Check~1
//Info~1
//Load~1
//System.out.println("Finished~2
//This~2
//if~1
//rmiRegistry.unbind(masterServerRegistryKey);~1
//the~1
10~1
:~12
=~135
Adding~2
ArrayList<FilePartition>~1
BufferedReader~1
BufferedWriter(new~1
ConcurrentHashMap<Integer,HashMap<String,Node>>();~1
Config~1
DFS");~1
Determines~1
DistributedFile(originalFile);~1
File(j.getJid()~1
FileIO.download(host,~1
Files~2
InetAddress~2
InputStream~1
Integer.parseInt(prop.getProperty("REGISTRY_PORT"));~1
Integer>~1
Job~4
LinkedList<Node>~1
LinkedList<Object[]>();~1
List<Node>~1
Looks~1
Map~1
NodeFileServerInterface~2
Nodes~2
Object[]~1
Partition~1
RMIInputStreamImpl(new~1
ReduceTask~2
ReduceTask(i,j.getJid(),null,j,localDir~1
RemoteException~9
Scheduler~3
Scheduler();~1
System.out.println("Error");~1
System.out.println("Failed~1
System.out.println("HeartBeater~1
System.out.println("Making~1
System.out.println("Sent~1
System.out.println("Unable~2
System.out.println("Unrecognized~1
System.out.println(address~2
System.out.println(tasks);~1
Task~4
Use~1
a~11
adds~1
all~9
allocateFile(DistributedFile~1
allocateFile(dfile);~1
and~7
any~1
b;~1
based~1
be~5
block~1
boolean~4
chars~1
check);~1
client"~1
commit(dfile);~1
could~1
created");~1
d~2
dfile.getBlocks().listIterator();~2
dfile.getFileName());~1
do~3
done,~1
e)~16
eachNode.files.size()~1
eachPartition.getLocation();~1
eachTask.getJob();~1
en~1
enumerate~3
f.delete();~2
fileConfig.txt~1
for:~1
formatted~2
foundNode.name);~1
fp~1
fp.getSize()~1
fps,~1
from~6
has~2
host)~1
host;~1
i);~3
i++)~4
in;~1
information~3
int~13
is~10
isConnected;~1
iter~5
j~3
j.getDFile().getBlocks();~1
j.getTotalReduces()){~1
j.getTotalReduces();~2
java.rmi.*;~1
java.rmi.registry.*;~1
java.util.*;~1
jobMapNodeList.put(jid,new~1
jobReduceNodeList.get(j.getJid()).get(fileName);~1
jobReducesDone.put(j.getJid(),reduces);~1
local~6
location~1
m~1
makes~1
maps~3
maptask~1
monitorAll()~1
must~1
n.cores~1
n.server.scheduleTask(m);~1
name.");~1
newFile~1
newNode~1
newNode.files~1
newNode.status~1
nodeQueue)~1
nodeQueue;~1
not~2
now~1
null)~8
null;~6
objs~1
old~1
one~1
part~1
partitionFile);~1
partitions~1
place~1
placedNodes~1
prop.getProperty("MASTER_SERVER_REGISTRY_KEY");~1
read~1
register(NodeFileServerInterface~1
replica~2
rmi~1
s~22
s.concat(each.isConnected~1
scheduleMap((FilePartition[])objs[0],(MapTask)t);~1
scheduleMap(FilePartition[]~1
stop~3
t)~1
t.getTaskId());~1
tasks~1
than~1
that~2
they~1
this.currentJid~1
this.masterServerRegistryKey~1
this.partitionFile(newFile);~1
thismaster~1
users~1
we~3
what~1
"Connected"~1
"\n";~1
"\n\tConnected"~1
"\n\tFiles~1
'this'~1
((oldsize~1
(int~1
(maps~1
+"~1
//Add~1
//Determine~1
//Download~1
//Send~1
//TODO:~2
//jid,~1
0)~1
0;~8
;~1
==~7
>~2
ConcurrentHashMap<String,~2
ConcurrentMap<Integer,List<FileServerInterface>>~1
Config.generateConfigFile();~1
Connected"));~1
DFS~1
END~1
FileInputStream(configFileName));~1
FileReader(f));~1
HashMap<String,Node>());~1
Iterator<DistributedFile>~1
LinkedList<DistributedFile>();~1
LinkedList<FileServerInterface>());~1
List<FilePartition[]>~1
ListIterator<FilePartition>~1
ListIterator<FilePartition[]>~2
Map"~1
Maps~1
Master's~1
Node>~1
Object[]{null,r});~1
Place~2
PrintWriter~1
Properties~1
Stopped");~2
System.exit(0);~2
System.out.println("Done~1
System.out.println("File~6
System.out.println("Incorrectly~1
System.out.println("Stopping~2
System.out.println(System.getProperty("sun.rmi.transport.tcp.responseTimeout"));~2
System.out.println(each.name~1
TODO:~1
Thread.sleep(10);~1
afs~1
among~1
args)~1
as~1
b~1
been~1
block.length;~1
catch~12
catch(IOException~1
clean~1
connected");~2
currentJid++;~1
currentJid;~1
currentNodeId;~1
distributed~2
done~1
downloading");~1
e.printStackTrace(System.out);~3
each~4
each.address);~1
eachBlock~1
eachNode.server.cleanLocalDirectory();~1
eachNode;~1
else~5
enumerate.nextElement();~3
f)~2
f;~1
file~17
for(Node~1
fp.getFileName()~1
fps~1
fps.length;~1
get~2
host~3
i;~1
ignoring");~1
in~4
isRunning;~1
it~3
iter.next();~4
j);~1
j.setDFile(d);~1
jid~2
jobReducesDone.get(j.getJid())~1
key=value~1
local");~1
localDir~5
localDir.mkdirs();~1
location");~1
m);~1
m.setPartition(fps[ns.indexOf(n)]);~1
master");~1
monitorFiles()~1
n~3
n.server.scheduleTask(t);~1
name)~3
name,~1
name;~1
network~1
newFile,~1
newStat~1
newsize);~1
node~10
node");~1
nodeEnum.nextElement();~1
nodeQueue~1
nodes.elements();~1
null~3
on~7
optimalNode~2
originalFile)~1
out~3
parseFile(configFileName);~1
parts~1
prop~2
prop.load(new~1
r;~1
reached~3
registryPort;~1
return;~7
run()~2
s.concat(taskIter.hasNext()~1
scheduleReduce(ReduceTask~1
scheduleReducers(Job~1
scheduler.nodeQueue.add(foundNode);~1
self");~1
server's~1
server,~1
server;~2
size~1
stopNodes()~1
t~3
t.getJob();~2
tempNodeSize~1
tempSize.put(optimalNode,~1
this~4
this.jobReducesDone~1
this.registryPort~1
thisSize~1
to~24
void~19
when~1
||~1
}~104
